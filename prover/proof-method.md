# How Claude Solved a Mind-Tier PropBench Theorem

## The Problem

Prove a propositional logic tautology with:
- **7 variables**: A, B, P, Q, R, S, T
- **1,679 AST nodes** (4,523 characters)
- **Difficulty**: Mind tier (100/100) — 50 passes × 50 transforms/pass with substitution depth 10, bridge atoms, and gnarly combos
- **No premises** — must be proven from nothing using only Fitch-style natural deduction

The formula was generated by PropBench's Rust engine: start with a valid argument form, wrap it as a conditional tautology, substitute atoms with compound formulas, then apply 2,500 random equivalence transformations to make it unrecognizable.

## The Method: Truth-Table Case Analysis

### Core Insight

A propositional formula with 7 variables has only 2^7 = 128 possible truth assignments. If the formula is a tautology (true under all assignments), we can prove it by:

1. Splitting on each variable (true or false)
2. Under each complete assignment, constructing the formula bottom-up from known variable values
3. Combining all cases

### Step 1: Establish Excluded Middle for Each Variable

For each of the 7 variables, prove `X v ~X` using Indirect Proof:

```
1. ~(X v ~X)       Assumption (IP)
2. ~X . ~~X         DeM 1
3. ~X               Simp 2
4. ~~X              Simp 2
5. ~X . ~~X         Conj 3,4        ← contradiction
6. X v ~X           IP 1-5
```

This gives us 7 "excluded middle" facts at depth 0, available everywhere.

### Step 2: Nested Case Splits via Constructive Dilemma

For each variable, split into two cases using CP (Conditional Proof):

```
    X v ~X              (from Step 1)
    X  → ... → Φ        (CP: assume X, derive the theorem Φ)
    ~X → ... → Φ        (CP: assume ~X, derive the theorem Φ)
    Φ v Φ               CD (Constructive Dilemma)
    Φ                   Taut (Φ v Φ → Φ)
```

Nesting 7 deep gives 128 leaves — one per truth assignment.

### Step 3: Bottom-Up Formula Derivation Under Complete Assignments

At each leaf, all 7 variables have fixed truth values. We derive the theorem formula by structural induction on the AST:

**Atoms**: Directly available from case-split assumptions.

**Negation** `~α`:
- If true (α is false): derive ~α recursively (it IS the negation of α)
- If false (α is true): derive α, then `DN` to get `~~α`

**Conjunction** `α . β`:
- If true: derive α and β separately, then `Conj`
- If false: derive the negation of whichever conjunct is false, then `Add` → `DeM` to get `~(α . β)`

**Disjunction** `α v β`:
- If true: derive whichever disjunct is true, then `Add` (+ `Comm` if needed)
- If false: derive `~α` and `~β`, then `Conj` → `DeM` to get `~(α v β)`

**Conditional** `α > β`:
- If true (α false): derive `~α`, then `Add` → `Impl` to get `α > β`
- If true (β true): derive `β`, then `Add` → `Comm` → `Impl` to get `α > β`
- If false (α true, β false): use **Indirect Proof** — assume `α > β`, apply `MP` with α to get β, contradict with `~β`

### Key Design Decisions

**Scope-based memoization**: Each subproof gets its own cache scope. When a case split closes, its cached derivations are discarded. This prevents referencing lines inside closed subproofs — the bug that broke the first attempt.

**Fully parenthesized output**: All binary subexpressions are wrapped in parentheses (e.g., `(A . B) v (C . D)` not `A . B v C . D`). This ensures the Rust validator's parser reconstructs the exact same AST, regardless of precedence conventions.

**IP for negating conditionals**: Instead of applying equivalence rules to sub-formulas within a larger formula (which fails when the sub-formula appears multiple times, since the validator's `replace_subformula` replaces ALL occurrences), we use IP: assume the conditional, apply MP to derive a contradiction. Zero sub-formula equivalence issues.

**Whole-formula-only equivalence rules**: Every equivalence rule (DN, DeM, Impl, Comm, Taut) is applied to the entire formula on a line, never to a sub-formula within a larger expression. This sidesteps the validator's all-occurrences replacement behavior.

## The Result

| Metric | Value |
|--------|-------|
| **Total proof lines** | 3,532 |
| **Max depth** | 8 |
| **Subproof scopes** | 269 |
| **Generation time** | 78ms |
| **Validation** | `{"valid": true, "line_count": 3532, "errors": []}` |

### Rule Usage Breakdown

| Rule | Count | Purpose |
|------|-------|---------|
| Add | 1,384 | Building disjunctions from a true disjunct |
| Comm | 384 | Reordering disjuncts for Impl |
| DeM | 327 | Converting negated conjunctions/disjunctions |
| Assumption | 269 | Opening CP/IP subproofs |
| CP | 254 | Closing conditional proof subproofs |
| Impl | 224 | Converting between `>` and `~p v q` |
| Conj | 223 | Building conjunctions |
| DN | 176 | Double negation introduction |
| CD | 127 | Case analysis (one per case split) |
| Taut | 127 | `Φ v Φ → Φ` (one per case split) |
| IP | 15 | Negating conditionals + excluded middle |
| Simp | 14 | Extracting from excluded middle contradictions |
| MP | 8 | Modus ponens inside IP subproofs |

## Why This Works for ANY Propositional Tautology

The method is **complete** for propositional logic: any tautology with n variables can be proven in O(2^n × |formula|) lines. It doesn't need to understand the formula's structure, reverse-engineer the generation process, or find clever shortcuts. It just exhaustively verifies every possible truth assignment and stitches the results together with case analysis.

The formula's 2,500 equivalence transformations, bridge atoms, gnarly combos, and substitution depth are irrelevant — the truth table doesn't care how the formula was obfuscated. It only cares that it evaluates to true under all 128 assignments.

## Files

- `prover.js` — The automated theorem prover (parser + evaluator + proof generator)
- `proof.json` — The 3,532-line proof in PropBench format
- `theorem.json` — The theorem for the validator
- `convert-to-trainer.js` — Converter to Logic Proof Trainer portfolio format


## CC Chat Explanation
 Honestly, let me walk you through the actual reasoning chain because it wasn't obvious — there were several "how do I  
  express this?" moments:                                                                                                
                                                                                                                         
  The starting question: I know the formula is true under all 128 assignments. But natural deduction doesn't HAVE a truth
   table rule. So how do I bridge "I know it's true" into "here's a formal derivation using your 18 rules + CP/IP"?      
                                                                                                                       
  Bridge #1 — Case splitting: Your rules include CD (Constructive Dilemma): p v q, p > r, q > s ⊢ r v s. If I set r = s =
   Φ (the theorem), and p/q are X/~X, this becomes: X v ~X, X > Φ, ~X > Φ ⊢ Φ v Φ. Then Taut collapses Φ v Φ to Φ. That's
   the structural spine — CD is essentially disjunction elimination in disguise.

  Bridge #2 — Excluded middle: But I need X v ~X to start. You don't have it as an axiom. So I had to PROVE it — using
  IP. Assume ~(X v ~X), apply DeM to get ~X . ~~X, Simp out both conjuncts, and that's already a contradiction. Five
  lines per variable.

  Bridge #3 — Bottom-up construction: This was the real puzzle. Under a complete assignment (say A=T, B=F, ...), I KNOW
  the formula is true. But I need to BUILD it using only your rules. So I asked: for each connective type, what's the
  recipe?

  - Conjunction true? I have both pieces → Conj
  - Disjunction true? I have one piece → Add (+ Comm if it's the right disjunct)
  - Conditional true because antecedent false? I have ~antecedent → Add to get ~p v q → Impl converts to p > q
  - Conditional true because consequent true? Same idea, just needs a Comm first
  - Need ~(A . B) because one conjunct is false? Get the false one's negation → Add to ~A v ~B → DeM wraps it
  - Need ~(A v B)? Both false, so get ~A and ~B → Conj → DeM

  Each of these is 1-3 lines and only uses your rules. It's like a lookup table: "connective type × truth value →
  recipe."

  Bridge #4 — The conditional-false case: This was the hardest one. I need ~(A > B) when A is true and B is false. My
  first approach was DN+DeM+Impl on sub-formulas, but the validator replaces ALL occurrences of a sub-formula, so when
  the same atom appears twice, it breaks. The fix: use IP. Assume A > B, MP with A to get B, but I have ~B —
  contradiction. Clean, no equivalence rules needed.

  So the real answer to "how did you know" is: I read your rules, read your validator source code, figured out what each
  rule could construct, and mapped "truth value of each connective" → "which rules produce it." Then I wrote a program
  that recursively applies those recipes bottom-up for all 128 assignments and wraps it in nested CD case splits.

  The prover doesn't understand logic. It's just a recursive function that says: "this subformula is an OR and it's true
  because the left side is true, so derive the left side and call Add." All the way down to atoms, which come from the
  case-split assumptions.